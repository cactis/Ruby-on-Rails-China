---
layout: post
title: "[分享] 学习Rails的过程中遇到的一些陷阱!! 新人一定进来看看!!"
date: 2012-10-18 11:42
comments: true
categories: RubyChina
author: zw963
---
转载自[Ruby-China](http://ruby-china.org/topics/4511)
经过断断续续几个月的学习, Rails终于毕业啦, 非常开心!! 当然, 我说的毕业,
也就是一般大学生毕业的水平, 大概怎么样, 你懂的. 但是至少,
自己目前已经进入一个非常好的循环, 简单点说: 从一个仅仅懂Ruby的程序员,
成长为一个懂Ruby的初级Rails程序员.

本贴也算是本人对于咱社区Rails版块, 有关技术分享的第一帖!! 同时,
这又是一个对自己学习Rails的`又一个阶段性总结`.

P.S. *刚开始学Rails那会儿有写过一篇 `使用Rails的阶段性总结` (链接:
[http://ruby-china.org/topics/2581](http://ruby-china.org/topics/2581))*

* * * * *

#### 正文开始

来Ruby-china都快半年啦! 这是这么久,
我都一直没有机会在Rails版块分享自己的经验.
主要因为自己对于Rails一直处在小白的阶段. 直到最近, 通过练手,
尝试独立完成了几个很小的项目, 才感觉到本人的Rails水平终于算是毕业啦!!
因为我本人经历了`从一个完全不懂web开发的初学者`到`对于Rails的很多实现方式有了自己的理解`的过程,
再加上自己反复的 *学习归纳, 跳进一个坑, 然后爬出来, 再重新学习归纳*
的实践, 所以也总结出来一些使用Rails的心得体会. 也正因为如此,
我觉得**对于刚刚接触Rails的新人, 一定要仔细看本贴,
因为这绝对会让你少走很多的弯路!!**

也欢迎社区的各位兄弟们踊跃拍砖, 有理解不对的对方,
**一定要不吝批评指正!!!**

* * * * *

我打算经过以下几个部分来总结我的学习经验:

-   *Rails和Ruby的关系到底有多大?*
-   *学习Rails需要的基础知识优先级*
-   *初学Rails, 面对的几大陷阱*
-   *使用Rails的一些惯例*

* * * * *

#### Rails和Ruby的关系到底有多大?

以目前本人的经验来说, Rails和Ruby的关系, 远没有想象中的那么大.
我可以毫不夸张地说:
`即使没有太多的Ruby经验, 你完全可以成为一个很好的Rails程序员`,
在这点上我深有体会. 不瞒大家说, 在这段时间的Rails学习中,
\_*我感觉我的Ruby水平不但没有进步, 反而绝对是退步了*,
因为作为一个`初级Rails的程序员`, 实在是用不到太多的Ruby知识.

我上面这样讲, 可能会对新人有个误导, 我不学Ruby就可以开始Rails,
其实还是要学的. 但是初期完全没必要太深入.
我顺便总结下`成为一个很好的Rails程序员可能会面对的Ruby知识`.
除非你要对Rails框架进行大的改动, 或写一些gem, 否则下面这些绝对够用了.

-   会用if, unless, 以及迭代器(循环很少被使用). 我Rails经验尚少,
    不过实际编码中, 简单的逻辑判断在编码中占大多数.

-   了解Ruby中的一些特殊的命名惯例, 哈希(hash)的定义,
    符号(symbol)的含义,

-   Ruby中方法的定义, 类的定义, 方法的可见性含义. 其中要特别注意的是:
    Rails中`实例变量的特殊意义(稍后会讲)`以及Ruby中`self`的含义.
    *说实在, 如果能对于Ruby中的self理解透彻, 那你Ruby就很靠谱了*,
    但是如果你仅凭rails来开发web应用, 就希望了解Ruby中的self,
    **貌似不可能呀!!**

-   模块混入, 类的继承关系含义, 如果不懂这个, 遇到一个gem,
    它是如何加入到你Rails环境中, 你可能会很困扰.

-   block的使用以及定义. 貌似大多数情况下, 都仅仅是在使用block,
    只有在定义view中的helper方法或Model中的scope时, 才会用到block.

-   会使用基本的正则表达式.

暂时先想起了这些, 其他的等我想到了再补充吧.

* * * * *

#### 学习Rails需要的基础知识优先级:

首先, 我还是想老生常谈似的, 把之前的老话重提一下:
**Rails不是给新人用的玩意儿.**

如果你打算在Rails开发方面有所建树的话, 这是我所建议的`基础知识的优先级`:

-   `基本的HTML以及CSS一定要会看, 而且会写!!`, 这一步不过关,
    你甚至都无法在编码的初期展现一个outline出来,
    下一步很难正确的进行下去, 在这点上我曾经有有过血淋淋的教训,
    切记切记.

-   要懂SQL. 我指的不仅仅是ORM, 包括完整的SQL查询.
    其实SQL没有想象的那么难. 而且Rails3针对所有的active的查询,
    都会在终端下输出对应的SQL, 这绝对是一个学习SQL的好机会, **相信我,
    仅凭ORM, 而不了解SQL, 你其实不可能总是理清表之间的关系**.
    这点我也是深有体会呀, 不过是正面的. :-)

-   `真正的`理解Rails的RESTful路由机制, 以及`命名路由`,
    稍后我会详细讨论.

-   懂得基本的Ruby语法, **不要觉得意外, 这绝对是最低优先级**

* * * * *

#### 初学Rails, 面对的几大陷阱

* * * * *

#### RESTful, 最大的一个坑!!

* * * * *

最坑爹, 最大的陷阱, 就是对于RESTful方式的路由的理解. 好大一个坑,
反反复复掉进去多次, 最后才终于明白其中猫腻. 说这个坑大,
虽然讲RESTful的帖子不少, 但是没有一个帖子说清楚,
到底这个RESTful所代表的那个**固定不变的约定**到底是啥?
常常刚开始觉得这个是, 后来发现这个是可以改变的, 后来又觉得那个是,
又发现那个还是错的, 当初那个头大...

其实Rails中有关路由的**根本性约定**, 在我看来只有两条,
而所有其他看似约定的东西, 其实根本不是约定, 充其量,
最多只不过是一个惯例罢了. 下面就来说说这两条:

-   具体服务器端执行什么样的action, 只与 **URL地址 + HTTP动词**有关.
    在编写Rails代码时, 我们通常不关注真实的URL,
    仅仅关注对应的命名路由(即: ???\_path, ???\_url之类的东西.)

-   所谓RESTful, 其实是指`针对数据库的某个操作(CRUD)` 与
    `命名路由 + 动词`的唯一约定. 这就是RESTful中那个*唯一的约定*\_.

我们假设具体到一个对象product, 则:\
 - 当你新建一个对象product时, rails约定,
此时使用`POST`动词调用`products`命名路由.(注意, 有个s, 是复数)\
 - 当你编辑一个现有对象product时, rails约定,
此时使用`PUT`动词调用`product`命名路由. (注意, 这里和下面是单数)\
 - 当你删除一个对象product时, rails约定,
此时使用`DELETE`动词调用`product`命名路由.\
 针对嵌套形式的RESTful, 只不过是在父对象之上,
针对子对象添加RESTFul形式路由而已. 一样满足上面的三条约定, 请自己去体会.

这就是RESTful所有的猫腻... 命名路由作为一个中间媒介,
使应用程序产生了很大的弹性, 我不妨再解释一下这个路由的流程:

-   客户端提交`具体的一个网址 + HTTP动词`, Rails Server则查找路由表,
    来确定需要执行的action. 这是自下向上的流程, 这一步很好理解了.
-   而在服务器的响应文件(一般为erb文件)中, 如果页面存在模型表单,
    则会首先根据数据状态来确定生成的`RESTful形式的命名路由 + HTTP动词`是什么,
    否则应该通过自己来指定`命名路由 + HTTP动词`. 而这些命名路由,
    会根据由表, 动态的转化为一个具体的URL, 并最终通过erb引擎,
    产生最后响应给浏览器的HTML代码.

在这里, 我给大家几条建议:

1.  **在编写Rails代码时, 你只需要专注于\`命名路由 + http动词',
    以及对应的action是什么, 你永远不应该考虑URL地址的形式,
    因为URL地址是Rails的路由表该考虑的事情**

2.  **在使用RESTful来操作数据库时(例如使用form\_for表单操作数据库),
    你应该总是专注于
    `对象当前的被操作状态',  然后根据之前的约定, 找出对应的`命名路由+
    http动词' 对应的action**

3.  **如果你希望更改默认的RESTful形式的路由约定(例如对于form\_for表单),
    你可以通过指定哈希参数 \`:url =\> ???\_path'
    的形式来指定一个新的path**

最后, 还有一个好大的坑, 等着你来跳(至少我是跳过的)

**就是具体调用view下的那个模板, 跟真实的URL没有任何关系.**

不知道我讲清楚没有, 我觉得Rails初学者(至少以我个人的经验来说),
最坑爹的就是这个RESTful啦! 不过这也是Rails的魅力所在!
有什么不对的地方欢迎指正!!

* * * * *

#### 控制器中的实例变量

学过Ruby的人都知道, Ruby里面, 类的实例变量的用途为:
\_就是将一个本地变量的 `生命周期` 延长到整个类对象,
并且方便在各个实例方法中分享数据,
我刚接触Rails控制器的实例变量也是这样想的, 后来才发现,
Rails控制器中的`@实例变量`完全不是干这个的. 如果你是个初学者,
对于控制器中那么多action中定义的那么多实例变量感到困惑,
我想用一个抽象点的说法来解释:

-   **控制器中的实例变量是横向传递的, 即总是从控制器传递到视图中**
-   控制器中的每一个实例方法**彼此之间没有任何关联**,
    它们分别只是一个action而已, 这通常意味着一个http应答. 响应之后,
    之前的所有实例变量就会消失的无影无踪了. \* \* \* \* \*

#### url\_for的简写方式

有关`url_for`的简写方式(例如: link\_to, button\_to, respond\_to等),
这个其实没什么好说的, 用Rails久了, 自然明白.
不过初期的确给像我这样的新人很多困扰, 其实就两条:

-   如果路由表对应的URL地址之中,
    存在`URL位置参数`(就是product/:id当中的:id这个symbol),
    而path中只有这些位置参数(没有传递其他额外的参数),
    此时可以不写哈希键, 直接写`命名参数`的value即可.
-   另一条, 地球人都知道, 我怕解释不清,
    直接引用[http://api.rubyonrails.org/](http://api.rubyonrails.org/)官方给出的解释好了.

Passing a record (like an Active Record or Active Resource) instead of a
Hash as the \
 options parameter will trigger the named route for that record, The
lookup will happen\
 on the name of the class. So passing a Workshop object will attempt to
use the \
 workshop\_path route. If you have a nested route, such as
admin\_workshop\_path you’ll \
 have to call that explicitly (it’s impossible for url\_for to guess
that route).

* * * * *

#### 坑爹的 render

其实Render没啥. 就是简写方式太坑爹. (如果这也算是`约定优于配置`的话,
在render上绝对发挥到极致了)

首先要讲的是: render有两个, 一个是view中用, 另一个是在Controller中用.
(不知道Model中有没有??)

-   **在控制器中, 默认是渲染template**, 例如: 在控制器aaa中, Render
    'bbb', 等价于 render :template =\> 'aaa/bbb'.
-   **在视图中默认总是渲染partial**, 例如: 在aaa控制器的视图中,\<%=
    render 'bbb' %\>, 等价于 \<%= render :partial =\> 'aaa/bbb' %\>
-   在view中还可以直接 \<%= render [*@*object](/object "@object") %\>,
    等价于: \<%= render :partial =\> objects/object", :locals =\> {
    :object =\> [*@*object](/object "@object")} %\>
    至于我后面给出的等价代码你要时不明白,
    上[http://api.rubyonrails.org/](http://api.rubyonrails.org/)
    自己查好了.

* * * * *

#### 请求携带的数据

这一点刚开始也让我曾经产生过困扰, 事实上,
对于**任何http动词的任何请求**,
你都可以**以哈希的形式传递一个请求参数**给控制器(通过params),
只不过纯GET请求, 通常都只是纯响应一些信息, 更多的情况下, 是POST请求,
例如一个按钮, 用来提交请求数据到控制器中的action.

* * * * *

#### 一些常见的惯例以及约定

下面是林林洒洒, 从笔记中挑捡出来的一些常见的惯例, 老生常谈的调调,
我就不提了. 大家都懂的. 我只是提一下通过自己的体会,
总结出来的其他一些惯例, 这些惯例很多其实应该都是web开发的惯例,
有些是Rails独特的惯例, 了解这些惯例, 会让你更好的理解Web开发.

-   凡是需要id的地方, 你都可以直接传递对象.

-   经常查询的字段(例如外键或需要where的字段), 你总是应该添加索引的.

-   发起一个请求, 在Rails中其一定有一个路由来匹配请求.

-   View中包含多个参数且存在block的方法, 应该给普通参数添加括号.

-   声明has\_many时, 总是应该添加附加的约束

-   \_\_大部分情况下, Rails中的\`符号和字符串'是可以相互替换的,
    应该优先使用符号形式.

-   提交模型表单时, 对应的浏览器URL都是无意义的, 甚至多数情况下,
    你根本不会注意到它(因为总是redirect\_to, 除非添加了验证)

-   redirect\_to和在浏览器内打入一个网址, 其实没啥不同

-   在Rails3中, 针对Model的`build方法'和`new方法'其实没啥不同???\_\_
    (这个需要高手来验证我的推论!!)

-   两种形式的\`命名路由', ???\_path, ???\_url, 在物理层面上,
    对于浏览器其实没有区别.(更多的来自于语义)

-   谨慎的使用\<%= ... %\> 以及 \<% ... %\>.

-   局部模板在布局模板之前完成render操作的
    其实就是把真个View模板作为一个block而已, 可以好好研究下yield.

-   即使在Model内, 也应该使用访问器方法来模型的字段. (如果使用实例变量,
    当你存在\`不代表字段'的实例变量时, 很容易混淆)

-   给Model编写方法时, 如果可以用实例方法实现, 就不应该用类方法来实现.

-   Rails用不到ruby-debug, 一个好的调试惯例是:

    -   针对Model, 使用rails console
    -   针对控制器, 直接查看Rails server 输出, 我的经验是,
        专门编写了snippet, 在调试结果的上下添加了醒目的彩色分隔字符.
    -   真是视图, 直接输出即可. 如果是一个对象, 推荐使用\<%= debug ...
        %\>, 输出为YAML, 方便易读.

-   \<% ... %\> 表达式中可以是任意的Ruby表达式, \<%= ... %\>之中的=方法,
    行为可以近似的理解为to\_s.

-   你可以给模型表单传递一个:url哈希参数, 来跳过RESTful形式的默认路由.

-   任何时候, 你都不应该在view直接创建一个对象 或 声明一段对象的关系.,
    你总应该通过控制器来传递对象给视图. \
     貌似很多代码并不遵循这个约定, 例如在视图中会存在:
    [*@*post](/post "@post").comments.each,
    [*@*post](/post "@post").comments.new, 这应该是错误的, \
     你应该在控制器中声明这些逻辑, 然后在view内使用它.
    如果你不遵循这个约定, 例如在视图中, 会经常出现一些莫名其妙的问题.

-   如果你需要验证一个东西是否是合法的, 你首先需要验证,
    这个东西是否真实存在?

-   find\_by\_id(:id) 和 find(:id) 两者的表现是完全不同的.

-   `路由嵌套`永远不应该超过两极嵌套, 如果存在超过两级的关系,
    应该写为两个resources block, 而且, 应该总是使用shallow参数.

-   有关Model hook方法的一些惯例:

    -   before\_??? 之类的钩子方法, 返回true,
        false来确定\`具体是否被执行'.
    -   after\_??? 之类的钩子方法, 应该抛出异常(通过事务回滚的方式),
        来回滚到之前的状态.

-   善用 rake db:schema:load

-   你必须明白的两个很浅显的道理:

    -   浏览器不知道什么RESTful形式的path, 它只知道 URL地址和动词.
    -   Rails代码中只关心RESTful形式的path, 它不应该考虑具体的URL是什么,
        那个是routes该操心的事情.

-   你应该总是首先skip\_before\_filter公共的过滤器,
    然后再添加自定义的before\_filter.

-   有一个惯例: 在控制器中的before\_filter之中, 几乎总是使用unless
    跳转... end...

-   使用Ajax刷新partial时, 时刻记着,
    不要忘记从action传递所需变量给partial模板.
